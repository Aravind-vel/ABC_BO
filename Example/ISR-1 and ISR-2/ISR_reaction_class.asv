classdef ISR_reaction_class

    properties        

        time_bound = [1,10]; % min
        reag_eq_bound = [1,2]; % eq
        cat_load_bound = [5,20]; % mol %

        this.inj_volume = 214; %micro l
        this.lim_stock = 0.5; %M
        reag_stock = 0.5; %M excess reagent
        this.cat_stock = 0.05; %M
        reactor_vol = 5; %ml
        mol_weight_product = 246;

    end

    methods
        function this = ISR_reaction_class

        end

        function [objective_value] = Objective_value_calculation(this, exp_condition, yield)

            % Return objective value [Throughput] g h-1 

            cat_mol = exp_condition.cat_load;
            cat_eq = cat_mol*0.01;
            reag_eq = exp_condition.reag_eq;
            time = exp_condition.time;
            
            % volume of limiting in a fixed total volume
            volume_lim = (this.reag_stock*this.this.inj_volume)/(this.reag_stock+this.this.lim_stock*(((cat_eq*this.reag_stock)+(reag_eq*this.this.cat_stock))/(this.this.cat_stock)));
            % final concentration of limiting in total volume
            conc_lim_aftermix = this.this.lim_stock * volume_lim /this.this.inj_volume;

            throughput = yield * 0.01 * conc_lim_aftermix * this.reactor_vol/(time); %mol/min
            throughput = throughput * this.mol_weight_product * 0.001 / 0.01667; % g/h

            objective_value = throughput;

        end

        function boundary_update = Boundary_update(this, objective_value)

            
            % variable values favoring objective 
            time = min(this.time_bound);
            cat_load = min(this.cat_load_bound);
            cat_eq = cat_load*0.01; 
            reag_eq = min(this.reag_eq_bound);

            %% time boundary limit

            % volume of limiting in a fixed total volume
            volume_lim = (this.reag_stock*this.this.inj_volume)/(this.reag_stock+this.this.lim_stock*(((cat_eq*this.reag_stock)+(reag_eq*this.this.cat_stock))/(this.this.cat_stock)));
            % final concentration of limiting in total volume
            conc_lim_aftermix = this.this.lim_stock * volume_lim /this.this.inj_volume;

            throughput = (objective_value*0.01667)/(this.mol_weight_product*0.001); % mol/min
            time_limit = 100 * 0.01 * this.conc_lim_aftermix * this.reactor_vol/(throughput);
            %% reagent eq and catalyst loading boundary limit
            conc_lim_aftermix = (throughput*time)/(100*0.01*this.reactor_vol);
            volume_lim = (conc_lim_aftermix*this.this.inj_volume)/this.this.lim_stock;

            reag_eq_limit =  [(((this.reag_eq_stock*this.inj_volume)/(volume_lim*this.lim_stock))-(this.reag_eq_stock/this.lim_stock))]-[(cat_eq*this.reag_eq_stock)/this.cat_stock];
            cat_eq_limit = [(((this.reag_eq_stock*this.inj_volume)/(volume_lim*this.lim_stock))-(this.reag_eq_stock/this.lim_stock))]*(this.cat_stock/this.reag_eq_stock)-[(reag_eq*this.cat_stock)/this.reag_eq_stock];
            cat_load_limit = cat_eq_limit*100;
            %% electrophile stoic limit
            elec_stoic_limit = ((product_formed/(objective_value*exp_condition.time))...
                -cost_all.base-cost_all.catalyst-cost_all.ligand)*this.density.(exp_condition.electrophile)/(this.cost.(exp_condition.electrophile)* this.lim_reagent_ini*this.molecular_weight.(exp_condition.electrophile));

            %% categorical variable levels that are futile

            % ligand 
            ligand_futile = cell(0,0);
            for l = 1:numel(this.ligand_options)
                % all combo of ligand
                row_numbers = find(strcmp(reag_combination(:,1),this.ligand_options{l}));
                % obj values corresponding to all combo of this ligand
                if all(obj_combo(row_numbers,:)<objective_value)
                    % mark ligand as futile
                    ligand_futile{end+1} = this.ligand_options{l};
                end
            end


            % base
            base_futile = cell(0,0);
            for b = 1:numel(this.base_options)
                % all combo of base
                row_numbers = find(strcmp(reag_combination(:,2),this.base_options{b}));
                % obj values corresponding to all combo of this base
                if all(obj_combo(row_numbers,:)<objective_value)
                    % mark base as futile
                    base_futile{end+1} = this.base_options{b};
                end
            end

            % electrophile
            electrophile_futile = cell(0,0);
            for e = 1:numel(this.electrophile_options)
                % all combo of base
                row_numbers = find(strcmp(reag_combination(:,3),this.electrophile_options{e}));
                % obj values corresponding to all combo of this electrophile
                if all(obj_combo(row_numbers,:)<objective_value)
                    % mark electrophile as futile
                    electrophile_futile{end+1} = this.electrophile_options{e};
                end
            end


           %% boundary update
           boundary_update.time = time_limit;
           boundary_update.catalyst_conc = catalyst_conc_limit;
           boundary_update.elec_stoic = elec_stoic_limit;
           boundary_update.electrophile = electrophile_futile;
           boundary_update.ligand = ligand_futile;
           boundary_update.base = base_futile;
            
        end
        


    end



end

